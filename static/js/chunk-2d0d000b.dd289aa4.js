(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0d000b"],{"65b8":function(n,t,e){"use strict";e.r(t);var o=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticStyle:{margin:"20px 10%"}},[e("v-md-preview",{attrs:{text:n.text}})],1)},s=[],r='\n######  tags: `自動化測試`\n前端的測試常見的有兩大類別：\n1. **Unit Test**：中文稱為單元測試，是以一個行為進行測試，可驗證運行是否符合結果。\n2. **E2E Test**：直接模擬使用者在瀏覽器上的行為做測試\n\n# Jest\n單元測試的工具 , Vue 的 Cli 中也是可做為預設的單元測試選項\n使用 yarn 安装 Jest︰\n```\nyarn add --dev jest\n```\n或 npm\n```\nnpm install --save-dev jest\n```\n\n基本配置\n\n建一個 sum.js\n```  jsx\nfunction sum(a, b) {\n  return a + b;\n}\nmodule.exports = sum;\n```\n\n建 sum.test.js\n``` jsx\nconst sum = require(\'./sum\');\n\ntest(\'adds 1 + 2 to equal 3\', () => {\n  expect(sum(1, 2)).toBe(3);\n});\n```\n\npaskage.json 添加\n``` js\n{\n  "scripts": {\n    "test": "jest"\n  }\n}\n```\n\n**ps**: 執行若是出現 *TypeError: environment.teardown is not a function* , 須先砍掉 node_module , package.lock , yarn.lock, 重新 yarn install ,npm install 即可解決\n\n\n## Component\n\n最重要的角色莫過於一個一個組件了，因此正式開始測試前，我們必須先透過方法，渲染出組件。\n首先先簡單創立一個 Component 稱為 UserForm。UserForm 的內容為以下：\n```  javascript\n<template>\n  <form @submit.prevent="submit">\n    <input type="text" v-model="id" />\n    <button type="submit">{{ text }}</button>\n  </form>\n</template>\n\n<script>\nexport default {\n  name: "UserForm",\n  props: {\n    text: {\n      type: String,\n      required: true\n    }\n  },\n  data() {\n    return {\n      id: ""\n    };\n  },\n  methods: {\n    submit() {\n      this.$emit("submit", { id: this.id });\n    }\n  }\n};\n<\\/script>\n```\n\n此組件內容為一個輸入框，用以接收 id 資料。以及一個按鈕，按鈕的文字來自 Props text。\n接下來以 UserForm 為例，有兩個方式可以渲染它。\n\n1. mount\n2. shallowMount\n\n### mount 與 shallowMount 差異處\nVue Component 常常會有子父層關係，使用 mount 會真實將所有子層渲染出來；shallowMount 則只渲染該組件，不渲染子層們。\n假設於 views 當中的 home，渲染 UserForm 組件，並分別使用 mount 及 shallowMount 印出 html。\n\n![](https://i.imgur.com/A15ob8q.png)\n\n可以發現使用 shallowMount 渲染出來的 UserForm 組件並不完整，子組件被 stub 替換掉了，成了一個假的組件。\n\n當只想測試特定組件的內容時，shallowMount 就會優於 mount。\n\n## Prop\nProps 的資料被當成 mount 或 shallowMount 的第二個參數傳入，例如：\n![](https://i.imgur.com/LupnVwD.png)\n\n接著需要測試 Props 進來的文字，是否被正確渲染在 button 按鈕上。必須先抓到 button 元素，再抓取文字測試。\n\n抓取元素可以用 find 方法，find 方法接受常用的標籤選擇器、類別與 id 選擇器、屬性選擇器、偽類選擇器等。\n\n以上述為例，可以簡單使用標籤選擇器 wrapperUserForm.find("button") 。接著使用 text( ) 方法，抓取元素文字內容。\n\n完整測試如下：\n``` javascript\nimport { mount } from "@vue/test-utils";\nimport UserForm from "@/components/UserForm.vue";\n\ntest("測試 props 資料_按鈕文字", () => {\n  const propstext = "送出";\n  const wrapperUserForm = mount(UserForm, {\n    propsData: {\n      text: "送出"\n    }\n  });\n  expect(wrapperUserForm.find("button").text()).toBe(propstext);\n});\n``` ',u={data:function(){return{text:r}}},m=u,p=e("2877"),i=Object(p["a"])(m,o,s,!1,null,null,null);t["default"]=i.exports}}]);
//# sourceMappingURL=chunk-2d0d000b.dd289aa4.js.map